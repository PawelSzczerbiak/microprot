# snakemake run example:
# snakemake -j 32 --local-cores 8 --cluster-config cluster.json --cluster \
# "qsub -k eo -m n -l nodes=1:ppn={cluster.n} -l mem={cluster.mem}gb \
# -l walltime={cluster.time}" --directory "$@"

# snakemake -s Snakefile_minimal -n

import yaml
import re
import sys
from glob import glob
from os import makedirs
from os.path import basename, splitext, exists
from shutil import copyfile
from skbio import io

sys.path.append('/projects/microprot')
from microprot.scripts import split_search, process_fasta, \
                              snakemake_helpers, calculate_Neff


configfile: "config.yaml"
with open('%s%s' % (config['MICROPROT_MAIN'], '/paths.yml'), 'r') as f:
    paths = yaml.load(f)
with open('%s%s' % (config['MICROPROT_MAIN'], '/inputs.yml'), 'r') as f:
    inputs = yaml.load(f)

# execute *before* any rules
SEQ_file = inputs['inp_file']
SEQ_path = inputs['inp_path']
SEQ_from = inputs['inp_from']
SEQ_to = inputs['inp_to']
SEQS = process_fasta.extract_sequences('%s/%s' % (SEQ_path, SEQ_file),
                                       identifiers=(SEQ_from, SEQ_to))
SEQ_ids = []
for SEQ in SEQS:
    _seq = SEQ.metadata['id']
    _seq = _seq.replace('/', '_')
    _seq = _seq.replace('\\', '_')
    _seq = _seq.replace('|', '_')
    SEQ_ids.append(_seq)
    SEQ.metadata['id'] = _seq
    io.write(SEQ, format='fasta', into='%s/%s.fasta' % (inputs['MICROPROT_INP'],
                                                        _seq))
    io.write(SEQ, format='fasta', into='%s/%s' % (inputs['MICROPROT_OUT'],
                                                  'processed_sequences.fasta'))


def search_x(inp_0, out_0, config=None, dbs=None, log=None):
    indir = snakemake_helpers.trim(inp_0, '/')
    outdir = snakemake_helpers.trim(out_0, '/')
    for non_match in glob('%s/%s' % (indir, '*.non_match')):
        if snakemake_helpers.not_empty(non_match):
            process_fasta.split_fasta(process_fasta.extract_sequences(
                                      non_match), outdir=outdir)
    for hh_inp in glob('%s/%s' % (outdir, '*.fasta')):
        out_root = snakemake_helpers.trim(hh_inp, '.')
        shell('{paths[TOOLS][hhsuite]}/hhsearch -i {hh_inp} \
               {config} \
               -d {dbs} \
               -o {out_root}.out \
               -oa3m {out_root}.a3m 2> {log}')
    # TODO
    # touch only if all hhsearch steps complete successfully?
    shell('touch {out_0}')


def split_x(inp_0, out_0, step="NA", version=config['VERSION'],
            frag_len=None,
            p_val=None,
            e_val=None,
            prob=None,
            log=None):
    inpdir = snakemake_helpers.trim(inp_0, '/')
    for fasta_inp in glob('%s/%s' % (inpdir, '*.fasta')):
        hh_inp = re.sub('.fasta$', '.out', fasta_inp)
        outname = snakemake_helpers.trim(hh_inp, '.').split('/')[-1]
        outpath = snakemake_helpers.trim(out_0, '/')

        with open(log, 'a') as _log:
            _log.write('hh_inp= %s\nfasta_inp= %s\n step= %s\n frag_len= %s\n'
                       ' p_val= %s\n e_val= %s\n prob= %s\n' % (hh_inp,
                                                                fasta_inp,
                                                                step,
                                                                frag_len,
                                                                p_val,
                                                                e_val,
                                                                prob))
        split_search.mask_sequence(hh_inp, fasta_inp,
                                   subsequences_fp='%s/%s' % (outpath,
                                                              outname),
                                   min_fragment_length=frag_len,
                                   max_evalue=e_val,
                                   min_prob=prob,
                                   max_pvalue=p_val
                                   )
        match = '%s/%s.match' % (outpath, outname)
        non_match = '%s/%s.non_match' % (outpath, outname)

        if snakemake_helpers.not_empty(match):
            snakemake_helpers.append_db(match, step=step, version=version,
                                        db_fp=str(paths['MICROPROT_DB']))
        if snakemake_helpers.not_empty(non_match):
            shell('touch {out_0}')
        else:
            shell('echo "pass" > {out_0}')


rule all:
    input:
        expand(inputs['MICROPROT_OUT']+'/log/{seq}/msa_ripe.log',
               seq=SEQ_ids)


rule search_PDB:
    input:
        inputs['MICROPROT_INP']+'/{seq}.fasta'
    output:
        out = inputs['MICROPROT_OUT']+'/01-search_pdb/{seq}/{seq}.out',
        a3m = inputs['MICROPROT_OUT']+'/01-search_pdb/{seq}/{seq}.a3m'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/search_pdb.log'
    shell:
        '{paths[TOOLS][hhsuite]}/hhsearch -i {input} \
         {config[search_PDB][params]} \
         -d {paths[DBS][pdb70]} \
         -o {output.out} \
         -oa3m {output.a3m} 2> {log}'


rule split_PDB:
    input:
        inputs['MICROPROT_OUT']+'/01-search_pdb/{seq}/{seq}.out',
        rules.search_PDB.input[0]
    output:
        inputs['MICROPROT_OUT']+'/02-split_pdb/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/split_pdb.log'
    run:
        # produces output.match and output.non_match
        split_search.mask_sequence(input[0], input[1],
                                   subsequences_fp=output[0],
                                   min_prob=config['split_PDB']['params']['min_prob'],
                                   min_fragment_length=config['split_PDB']['params']['min_fragment_length'])
        match = '%s.match' % output[0]
        non_match = '%s.non_match' % output[0]

        if snakemake_helpers.not_empty(match):
            snakemake_helpers.append_db(match, step="PDB",
                                        version=config['VERSION'],
                                        db_fp=str(paths['MICROPROT_DB']))
        if snakemake_helpers.not_empty(non_match):
            open(output[0], 'a').close()


rule search_CM:
    input:
        inputs['MICROPROT_OUT']+'/02-split_pdb/{seq}/{seq}'
    output:
        inputs['MICROPROT_OUT']+'/03-search_CM/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/search_cm.log'
    run:
        if snakemake_helpers.not_empty(input[0]):
            shell('echo "pass" > {output}')
        else:
            search_x(input[0], output[0],
                     config=config['search_CM']['params'],
                     dbs=paths['DBS']['pdb70'],
                     log=log[0])


rule split_CM:
    input:
        rules.search_CM.output[0]
    output:
        inputs['MICROPROT_OUT']+'/04-split_CM/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/split_cm.log'
    run:
        if snakemake_helpers.not_empty(input[0]):
            shell('echo "pass" > {output}')
        else:
            split_x(input[0], output[0],
                    step="CM",
                    frag_len=config['split_CM']['params']['min_fragment_length'],
                    e_val=config['split_CM']['params']['max_evalue'],
                    log=log[0])


rule search_Pfam:
    input:
        inputs['MICROPROT_OUT']+'/04-split_CM/{seq}/{seq}'
    output:
        inputs['MICROPROT_OUT']+'/05-search_Pfam/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/search_pfam.log'
    run:
        if snakemake_helpers.not_empty(input[0]):
            shell('echo "pass" > {output}')
        else:
            search_x(input[0], output[0],
                     config=config['search_Pfam']['params'],
                     dbs=paths['DBS']['pfamA'],
                     log=log[0])


rule split_Pfam:
    input:
        rules.search_Pfam.output[0]
    output:
        inputs['MICROPROT_OUT']+'/06-split_Pfam/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/split_pfam.log'
    run:
        if snakemake_helpers.not_empty(input[0]):
            shell('echo "pass" > {output}')
        else:
            split_x(input[0], output[0],
                    step="Pfam",
                    frag_len=config['split_Pfam']['params']['min_fragment_length'],
                    e_val=config['split_Pfam']['params']['max_evalue'],
                    prob=config['split_Pfam']['params']['min_prob'],
                    log=log[0])


rule MSA_hhblits:
    input:
        inputs['MICROPROT_OUT']+'/06-split_Pfam/{seq}/{seq}'
    output:
        inputs['MICROPROT_OUT']+'/07-MSA_hhblits/{seq}/{seq}'
    log:
        inputs['MICROPROT_OUT']+'/log/{seq}/msa_hhblits.log'
    run:
        """
        it's essentially a copy of `search_x` function, but here we're using
        HHblits and it has a slightly different commandline input construction
        """
        indir = snakemake_helpers.trim(input[0], '/')
        outdir = snakemake_helpers.trim(output[0], '/')
        # here, we process both `match` and `non_match` sequences
        # Pfam is our "domain splitting" method
        for _match in glob('%s/%s' % (indir, '*match')):
            if snakemake_helpers.not_empty(_match):
                process_fasta.split_fasta(process_fasta.extract_sequences(
                                          _match), outdir=outdir)
        for hh_inp in glob('%s/%s' % (outdir, '*.fasta')):
            out_root = snakemake_helpers.trim(hh_inp, '.')
            shell('{paths[TOOLS][hhsuite]}/hhblits -i {hh_inp} \
                   {config[MSA_hhblits][params]} \
                   -d {paths[DBS][hhblits_db]} \
                   -o {out_root}.out \
                   -oa3m {out_root}.a3m 2> {log}')
        shell('touch {output}')


rule MSA_ripe:
    input:
        inputs['MICROPROT_OUT']+'/07-MSA_hhblits/{seq}/{seq}'
    output:
        inputs['MICROPROT_OUT']+'/log/{seq}/msa_ripe.log'
    run:
        shell('touch {output}')
        indir = snakemake_helpers.trim(input[0], '/')
        for infile in glob('%s/%s' % (indir, '*a3m')):
            inp_name = splitext(basename(infile))[0]
            msa = calculate_Neff.parse_msa_file(infile)
            hdm = calculate_Neff.hamming_distance_matrix(msa)
            clu = calculate_Neff.cluster_sequences(hdm,
                                                   config['MSA_ripe']['cutoff'])
            Neff = calculate_Neff.effective_family_size(clu, msa.shape[1])
            if Neff >= config['MSA_ripe']['Nf']:
                with open(output[0], 'a') as o:
                    o.write('%s %s %.1f\n' % (inp_name, "ripe:", Neff))
                dest = re.sub('07-MSA_hhblits', '10-Rosetta', infile)
                dest_dir = snakemake_helpers.trim(dest, '/')
                if not exists(dest_dir):
                    makedirs(dest_dir)
                copyfile(infile, dest)
            else:
                with open(output[0], 'a') as o:
                    o.write('%s %s %.1f\n' % (inp_name, "not ripe:", Neff))
                dest = re.sub('07-MSA_hhblits', '09-not_ripe', infile)
                dest_dir = snakemake_helpers.trim(dest, '/')
                if not exists(dest_dir):
                    makedirs(dest_dir)
                copyfile(infile, dest)
