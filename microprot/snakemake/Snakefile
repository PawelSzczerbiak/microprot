# snakemake run example:
# snakemake -j 32 --local-cores 8 --cluster-config cluster.json --cluster \
# "qsub -k eo -m n -l nodes=1:ppn={cluster.n} -l mem={cluster.mem}gb \
# -l walltime={cluster.time}" --directory "$@"

# snakemake -s Snakefile_minimal -n

import yaml
import re
import sys
from glob import glob

sys.path.append('/projects/microprot')
from microprot.scripts import split_search, process_fasta, \
                              snakemake_helpers, calculate_Neff


configfile: "config.yaml"
with open('%s%s' % (config['MICROPROT_MAIN'], 'paths.yml'), 'r') as f:
    paths = yaml.load(f)
with open('%s%s' % (config['MICROPROT_MAIN'], 'inputs.yml'), 'r') as f:
    inputs = yaml.load(f)

SEQUENCES = inputs['inp_file']
INP_PATH = inputs['inp_path']
SEQ_from = inputs['inp_from']
SEQ_to = inputs['inp_to']

## FOR NOW
config['MICROPROT_MAIN'] = '/projects/microprot/benchmarking/snakemake_minimal_test/'
##########


def search_x(inp_0, out_0, config=None, dbs=None, log=None):
    indir = snakemake_helpers.trim(inp_0, '/')
    outdir = snakemake_helpers.trim(out_0, '/')
    for non_match in glob('%s/%s' % (indir, '*.non_match')):
        if snakemake_helpers.not_empty(non_match):
            process_fasta.split_fasta(process_fasta.extract_sequences(
                                      non_match), outdir=outdir)
    for hh_inp in glob('%s/%s' % (outdir, '*.fasta')):
        out_root = snakemake_helpers.trim(hh_inp, '.')
        shell('{paths[TOOLS][hhsuite]}/hhsearch -i {hh_inp} \
               {config} \
               -d {dbs} \
               -o {out_root}.out \
               -oa3m {out_root}.a3m 2> {log}')
    # TODO
    # touch only if all hhsearch steps complete successfully?
    shell('touch {out_0}')


def split_x(inp_0, out_0, step="NA", version=config['VERSION'],
            frag_len=None,
            p_val=None,
            e_val=None,
            prob=None,
            log=None):
    inpdir = snakemake_helpers.trim(inp_0, '/')
    for hh_inp, fasta_inp in zip(glob('%s/%s' % (inpdir, '*.out')),
                                 glob('%s/%s' % (inpdir, '*.fasta'))):
        outname = snakemake_helpers.trim(hh_inp, '.').split('/')[-1]
        outpath = snakemake_helpers.trim(out_0, '/')

        with open(log, 'a') as _log:
            _log.write('hh_inp= %s fasta_inp= %s\n step= %s\n frag_len= %s\n'
                       ' p_val= %s\n e_val= %s\n prob= %s\n' % (hh_inp,
                                                                fasta_inp,
                                                                step,
                                                                frag_len,
                                                                p_val,
                                                                e_val,
                                                                prob))
        split_search.mask_sequence(hh_inp, fasta_inp,
                                   subsequences_fp='%s/%s' % (outpath,
                                                              outname),
                                   min_fragment_length=frag_len,
                                   max_evalue=e_val,
                                   min_prob=prob,
                                   max_pvalue=p_val
                                   )
        match = '%s/%s.match' % (outpath, outname)
        non_match = '%s/%s.non_match' % (outpath, outname)

        if snakemake_helpers.not_empty(match):
            snakemake_helpers.append_db(match, step=step, version=version,
                                        db_fp=str(paths['MICROPROT_DB']))
        # TODO
        # if non_match is not empty `touch $out.ok`, else `touch $out.pass`?
        # will this help avoid fails? i.e. in subsequent rules, if `ok` is
        # present, execte rule, if `pass`, just skip execution and pass on
        # another dummy file
        if snakemake_helpers.not_empty(non_match):
            shell('touch {out_0}')


rule all:
    input:
        config['MICROPROT_MAIN']+'results/log/seq2/msa_ripe.log'


rule search_PDB:
    input:
        "/projects/microprot/benchmarking/snakemake_minimal_test/seq2.faa"
    output:
        out = config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.out',
        a3m = config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.a3m'
    log:
        config['MICROPROT_MAIN']+'results/log/{seq}/search_pdb.log'
    shell:
        '{paths[TOOLS][hhsuite]}/hhsearch -i {input} \
         {config[search_PDB][params]} \
         -d {paths[DBS][pdb70]} \
         -o {output.out} \
         -oa3m {output.a3m} 2> {log}'


rule split_PDB:
    input:
        config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.out',
        rules.search_PDB.input[0]
    output:
        config['MICROPROT_MAIN']+'results/02-split_pdb/{seq}/{seq}'
    log:
        config['MICROPROT_MAIN']+'results/log/{seq}/split_pdb.log'
    run:
        # produces output.match and output.non_match
        split_search.mask_sequence(input[0], input[1],
                                   subsequences_fp=output[0],
                                   min_prob=config['split_PDB']['params']['min_prob'],
                                   min_fragment_length=config['split_PDB']['params']['min_fragment_length'])
        match = '%s.match' % output[0]
        non_match = '%s.non_match' % output[0]

        if snakemake_helpers.not_empty(match):
            snakemake_helpers.append_db(match, step="PDB",
                                        version=config['VERSION'],
                                        db_fp=str(paths['MICROPROT_DB']))
        if snakemake_helpers.not_empty(non_match):
            open(output[0], 'a').close()


rule search_CM:
    input:
        config['MICROPROT_MAIN']+'results/02-split_pdb/{seq}/{seq}'
    output:
        config['MICROPROT_MAIN']+'results/03-search_CM/{seq}/{seq}'
    log:
        'results/log/{seq}/search_cm.log'
    run:
        search_x(input[0], output[0],
                 config=config['search_CM']['params'],
                 dbs=paths['DBS']['pdb70'],
                 log=log[0])


rule split_CM:
    input:
        rules.search_CM.output[0]
    output:
        config['MICROPROT_MAIN']+'results/04-split_CM/{seq}/{seq}'
    log:
        'results/log/{seq}/split_cm.log'
    run:
        split_x(input[0], output[0],
                step="CM",
                frag_len=config['split_CM']['params']['min_fragment_length'],
                e_val=config['split_CM']['params']['max_evalue'], log=log[0])


rule search_Pfam:
    input:
        config['MICROPROT_MAIN']+'results/04-split_CM/{seq}/{seq}'
    output:
        config['MICROPROT_MAIN']+'results/05-search_Pfam/{seq}/{seq}'
    log:
        'results/log/{seq}/search_pfam.log'
    run:
        search_x(input[0], output[0],
                 config=config['search_Pfam']['params'],
                 dbs=paths['DBS']['pfamA'],
                 log=log[0])


rule split_Pfam:
    input:
        rules.search_Pfam.output[0]
    output:
        config['MICROPROT_MAIN']+'results/06-split_Pfam/{seq}/{seq}'
    log:
        'results/log/{seq}/split_pfam.log'
    run:
        split_x(input[0], output[0],
                step="Pfam",
                frag_len=config['split_Pfam']['params']['min_fragment_length'],
                e_val=config['split_Pfam']['params']['max_evalue'],
                prob=config['split_Pfam']['params']['min_prob'], log=log[0])


rule MSA_hhblits:
    input:
        config['MICROPROT_MAIN']+'results/06-split_Pfam/{seq}/{seq}'
    output:
        config['MICROPROT_MAIN']+'results/07-MSA_hhblits/{seq}/{seq}'
    log:
        'results/log/{seq}/msa_hhblits.log'
    run:
        """
        it's essentially a copy of `search_x` function, but here we're using
        HHblits and it has a slightly different commandline input construction
        """
        indir = snakemake_helpers.trim(input[0], '/')
        outdir = snakemake_helpers.trim(output[0], '/')
        # here, we process both `match` and `non_match` sequences
        # Pfam is our "domain splitting" method
        for _match in glob('%s/%s' % (indir, '*match')):
            if snakemake_helpers.not_empty(_match):
                process_fasta.split_fasta(process_fasta.extract_sequences(
                                          _match), outdir=outdir)
        for hh_inp in glob('%s/%s' % (outdir, '*.fasta')):
            out_root = snakemake_helpers.trim(hh_inp, '.')
            shell('{paths[TOOLS][hhsuite]}/hhblits -i {hh_inp} \
                   {config[MSA_hhblits][params]} \
                   -d {paths[DBS][hhblits_db]} \
                   -o {out_root}.out \
                   -oa3m {out_root}.a3m 2> {log}')
        shell('touch {output}')


rule MSA_ripe:
    input:
        config['MICROPROT_MAIN']+'results/07-MSA_hhblits/{seq}/{seq}'
    output:
        not_ripe = config['MICROPROT_MAIN']+'results/09-not_ripe/{seq}/{seq}.msa',
        ripe = config['MICROPROT_MAIN']+'results/10-Rosetta/{seq}/{seq}.msa',
        placeholder = config['MICROPROT_MAIN']+'results/log/{seq}/msa_ripe.log'
    run:
        shell('touch {output[placeholder]}')
        # TODO
        indir = snakemake_helpers.trim(input[0], '/')
        for infile in glob('%s/%s' % (indir, '*a3m')):
            msa = calculate_Neff.parse_msa_file(infile)
            hdm = calculate_Neff.hamming_distance_matrix(msa)
            clu = calculate_Neff.cluster_sequences(hdm,
                                                   config['MSA_ripe']['cutoff'])
            Neff = calculate_Neff.effective_family_size(clu, msa.shape[1])
            if Neff >= config['MSA_ripe']['Nf']:
                shell('echo "ripe" >> {output[placeholder]}')
                # cp infile to output['ripe']
            else:
                shell('echo "not ripe" >> {output[placeholder]}')
                # cp infile to output['not_ripe']
