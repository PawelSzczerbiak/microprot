# snakemake run example:
# snakemake -j 32 --local-cores 8 --cluster-config cluster.json --cluster \
# "qsub -k eo -m n -l nodes=1:ppn={cluster.n} -l mem={cluster.mem}gb \
# -l walltime={cluster.time}" --directory "$@"

# snakemake -s Snakefile_minimal -n

import yaml
import re
import sys
from glob import glob

sys.path.append('/projects/microprot')
from microprot.scripts import split_search, process_fasta, snakemake_helpers


configfile: "config.yaml"
with open('%s%s' % (config['MICROPROT_MAIN'], 'paths.yml'), 'r') as f:
    paths = yaml.load(f)
with open('%s%s' % (config['MICROPROT_MAIN'], 'inputs.yml'), 'r') as f:
    inputs = yaml.load(f)

SEQUENCES = inputs['inp_file']
INP_PATH = inputs['inp_path']
SEQ_from = inputs['inp_from']
SEQ_to = inputs['inp_to']
microprot_db_fp = '/tmp/microprot_db.index'


rule all:
    input:
        config['MICROPROT_MAIN']+'results/04-split_CM/seq2/seq2'


rule search_PDB:
    input:
        "/projects/microprot/benchmarking/snakemake_test/seq2.faa"
    output:
        out = config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.out',
        a3m = config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.a3m'
    log:
        config['MICROPROT_MAIN']+'results/log/{seq}/search_pdb.log'
    shell:
        '{paths[TOOLS][hhsuite]}/bin/hhsearch -i {input} \
         {config[search_PDB][params]} \
         -d {paths[DBS][pdb70]} \
         -o {output.out} \
         -oa3m {output.a3m}'


"""
in fact we should have 3 outputs:
    * {seq}.match
    * {seq}.non_match
    * {seq}.split pdb # placeholder for rule purposes
"""
rule split_PDB:
    input:
        config['MICROPROT_MAIN']+'results/01-search_pdb/{seq}/{seq}.out',
        rules.search_PDB.input[0]
    output:
        config['MICROPROT_MAIN']+'results/02-split_pdb/{seq}/{seq}'
    log:
        config['MICROPROT_MAIN']+'results/log/{seq}/split_pdb.log'
    run:
        # produces output.match and output.non_match
        split_search.mask_sequence(input[0], input[1],
                                   config['split_PDB']['params'],
                                   subsequences_fp=output[0])
        match = '%s.match' % output[0]
        non_match = '%s.non_match' % output[0]

        if snakemake_helpers.non_empty(match):
            append_db(match, step="PDB", version=1,
                      db_fp=microprot_db_fp)
        if snakemake_helpers.non_empty(non_match):
            open(output[0], 'a').close()


rule search_CM:
    input:
        config['MICROPROT_MAIN']+'results/02-split_pdb/{seq}/{seq}'
    output:
        config['MICROPROT_MAIN']+'results/03-search_CM/{seq}/{seq}'
    run:
        non_match = '%s.non_match' % input[0]
        outdir = snakemake_helpers.trim(output[0], '/')
        if snakemake_helpers.non_empty(non_match):
            process_fasta.split_fasta(process_fasta.extract_sequences(
                                      non_match), outdir=outdir)
            touch(output[0])
        for hh_inp in glob('%s/%s' % (outdir, '*.fasta')):
            out_root = snakemake_helpers.trim(hh_inp, '.')
            shell('{paths[TOOLS][hhsuite]}/bin/hhsearch -i {hhinp} \
                   {config[search_CM][params]} \
                   -d {paths[DBS][pdb70]} \
                   -o {out_root}.out \
                   -oa3m {out_root}.a3m')


rule split_CM:
    input:
        rules.search_CM.output[0]
    output:
        config['MICROPROT_MAIN']+'results/04-split_CM/{seq}/{seq}'
    run:
        inpdir = snakemake_helpers.trim(input[0], '/')
        for hh_inp, fasta_inp in zip(glob('%s/%s' % (inpdir, '*.out')),
                                     glob('%s/%s' % (inpdir, '*.fasta'))):
            outname = snakemake_helpers.trim(hh_inp, '.')
            # produces output.match and output.non_match
            split_search.mask_sequence(hh_inp, fasta_inp,
                                       config['split_CM']['params'],
                                       subsequences_fp=outname)
            match = '%s.match' % outname
            non_match = '%s.non_match' % outname

            if snakemake_helpers.non_empty(match):
                append_db(match, step="CM", version=1,
                          db_fp=microprot_db_fp)
            if snakemake_helpers.non_empty(non_match):
                open(output[0], 'a').close()
